use std::collections::HashMap;

use aries_askar::{
    entry::EntryTag,
    kms::{KeyAlg, KeyEntry, LocalKey},
    PassKey, Session, Store, StoreKeyMethod,
};
use async_trait::async_trait;

use super::rng_method::RngMethod;
#[cfg(feature = "vdrtools_wallet")]
use crate::WalletHandle;
use crate::{
    errors::error::{AriesVcxCoreError, AriesVcxCoreErrorKind, VcxCoreResult},
    utils::async_fn_iterator::AsyncFnIterator,
    wallet::{base_wallet::BaseWallet, structs_io::UnpackMessageOutput},
};

#[derive(Debug)]
pub struct AskarWallet {
    pub backend: Store,
    profile: Option<String>,
}

impl AskarWallet {
    pub async fn create(
        db_url: &str,
        key_method: StoreKeyMethod,
        pass_key: PassKey<'_>,
        recreate: bool,
        profile: Option<String>,
    ) -> Result<Self, AriesVcxCoreError> {
        let backend =
            Store::provision(db_url, key_method, pass_key, profile.clone(), recreate).await?;

        Ok(Self { backend, profile })
    }

    pub async fn open(
        db_url: &str,
        key_method: Option<StoreKeyMethod>,
        pass_key: PassKey<'_>,
        profile: Option<String>,
    ) -> Result<Self, AriesVcxCoreError> {
        let backend = Store::open(db_url, key_method, pass_key, profile.clone()).await?;

        Ok(Self { backend, profile })
    }

    pub async fn create_key(
        &self,
        name: &str,
        alg: KeyAlg,
        seed: &str,
        rng_method: RngMethod,
        metadata: Option<&str>,
        tags: Option<&[EntryTag]>,
    ) -> Result<(), AriesVcxCoreError> {
        let mut session = self.backend.session(self.profile.clone()).await?;

        let key = LocalKey::from_seed(alg, seed.as_bytes(), rng_method.into())?;
        Ok(session.insert_key(name, &key, metadata, tags, None).await?)
    }

    pub async fn create_did(&self, key_name: &str) -> Result<(), AriesVcxCoreError> {
        let mut session = self.backend.session(self.profile.clone()).await?;

        let key_entry = self.fetch_key_entry(&mut session, key_name).await?;

        let local_key = key_entry.load_local_key()?;

        let did_bytes = &local_key.to_public_bytes()?[0..16];

        let did = bs58::encode(did_bytes).into_string();
        Ok(session
            .insert("aries-did", &did, &did_bytes, None, None)
            .await?)
    }

    async fn fetch_key_entry(
        &self,
        session: &mut Session,
        key_name: &str,
    ) -> Result<KeyEntry, AriesVcxCoreError> {
        session.fetch_key(key_name, false).await?.ok_or_else(|| {
            AriesVcxCoreError::from_msg(
                AriesVcxCoreErrorKind::WalletRecordNotFound,
                format!("no key with name '{}' found in wallet", key_name),
            )
        })
    }
}

#[cfg(feature = "askar")]
#[async_trait]
impl BaseWallet for AskarWallet {
    #[cfg(feature = "vdrtools_wallet")]
    fn get_wallet_handle(&self) -> WalletHandle {
        todo!("Not yet implemented");
    }

    // ----- DIDs
    async fn create_and_store_my_did(
        &self,
        seed: Option<&str>,
        kdf_method_name: Option<&str>,
    ) -> VcxCoreResult<(String, String)> {
        todo!("Not yet implemented");
    }

    async fn key_for_local_did(&self, did: &str) -> VcxCoreResult<String> {
        todo!("Not yet implemented");
    }

    // returns new temp_verkey and remembers it internally
    async fn replace_did_keys_start(&self, target_did: &str) -> VcxCoreResult<String> {
        todo!("Not yet implemented");
    }

    // replaces the `target_did`'s current verkey with the one last generated by
    // `replace_did_keys_start`
    async fn replace_did_keys_apply(&self, target_did: &str) -> VcxCoreResult<()> {
        todo!("Not yet implemented");
    }

    // ---- records

    async fn add_wallet_record(
        &self,
        xtype: &str,
        id: &str,
        value: &str,
        tags: Option<HashMap<String, String>>,
    ) -> VcxCoreResult<()> {
        todo!("Not yet implemented");
    }

    async fn get_wallet_record(
        &self,
        xtype: &str,
        id: &str,
        options: &str,
    ) -> VcxCoreResult<String> {
        todo!("Not yet implemented");
    }

    async fn get_wallet_record_value(&self, xtype: &str, id: &str) -> VcxCoreResult<String> {
        todo!("Not yet implemented");
    }

    async fn delete_wallet_record(&self, xtype: &str, id: &str) -> VcxCoreResult<()> {
        todo!("Not yet implemented");
    }

    async fn update_wallet_record_value(
        &self,
        xtype: &str,
        id: &str,
        value: &str,
    ) -> VcxCoreResult<()> {
        todo!("Not yet implemented");
    }

    async fn add_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tags: HashMap<String, String>,
    ) -> VcxCoreResult<()> {
        todo!("Not yet implemented");
    }

    async fn update_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tags: HashMap<String, String>,
    ) -> VcxCoreResult<()> {
        todo!("Not yet implemented");
    }

    async fn delete_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tag_names: &str,
    ) -> VcxCoreResult<()> {
        todo!("Not yet implemented");
    }

    async fn iterate_wallet_records(
        &self,
        xtype: &str,
        query: &str,
        options: &str,
    ) -> VcxCoreResult<Box<dyn AsyncFnIterator<Item = VcxCoreResult<String>>>> {
        todo!("Not yet implemented");
    }

    // ---- crypto

    async fn sign(&self, my_vk: &str, msg: &[u8]) -> VcxCoreResult<Vec<u8>> {
        todo!("Not yet implemented");
    }

    async fn verify(&self, vk: &str, msg: &[u8], signature: &[u8]) -> VcxCoreResult<bool> {
        todo!("Not yet implemented");
    }

    async fn pack_message(
        &self,
        sender_vk: Option<&str>,
        receiver_keys: &str,
        msg: &[u8],
    ) -> VcxCoreResult<Vec<u8>> {
        todo!("Not yet implemented");
    }

    async fn unpack_message(&self, msg: &[u8]) -> VcxCoreResult<UnpackMessageOutput> {
        todo!("Not yet implemented");
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[tokio::test]
    async fn test_should_create_askar_wallet() {
        let uri = "postgres://postgres:postgres@localhost/askar";

        let profile = "foo".to_string();

        let wallet = AskarWallet::create(
            uri,
            StoreKeyMethod::Unprotected,
            None.into(),
            true,
            Some(profile.clone()),
        )
        .await
        .unwrap();

        let active_profile = wallet.backend.get_active_profile();
        assert_eq!(profile, active_profile);
    }

    #[tokio::test]
    #[cfg_attr(not(feature = "askar_tests"), ignore)]
    async fn test_should_open_askar_wallet() {
        let uri = "postgres://postgres:postgres@localhost/askar";

        AskarWallet::open(uri, Some(StoreKeyMethod::Unprotected), None.into(), None)
            .await
            .unwrap();
    }

    #[tokio::test]
    #[cfg_attr(not(feature = "askar_tests"), ignore)]
    async fn test_should_create_a_key_in_askar_wallet() {
        let uri = "postgres://postgres:postgres@localhost/askar";

        let wallet = AskarWallet::open(uri, Some(StoreKeyMethod::Unprotected), None.into(), None)
            .await
            .unwrap();

        let key_name = "first-key";
        wallet
            .create_key(
                "first-key",
                KeyAlg::Ed25519,
                "seed",
                RngMethod::RandomDet,
                None,
                None,
            )
            .await
            .unwrap();

        let mut session = wallet.backend.session(None).await.unwrap();

        let res = session.fetch_key(key_name, false).await.unwrap();
        res.map(|entry| assert_eq!(entry.name(), key_name));
    }
}
